

defmodule Comp do 
	def new(r, i) do {r, i} end
	def add({a1, a2}, {b1, b2}) do
		{a1 + b1, a2 + b2}
	end
	def sqr({r, i}) do 
		{(r*r - i*i), (2*r*i)}
	end
	def abs({r, i}) do 
		:math.sqrt((:math.pow(r, 2)+(:math.pow(i, 2))))
	end 
end

defmodule Mandel do
	def demo() do
  		small(-2.6, 1.2, 1.2)
	end
	
	def small(x0, y0, xn) do
  		width = 960
  		height = 540
  		depth = 64
  		k = (xn - x0) / width
  		image = Mandel.mandelbrot(width, height, x0, y0, k, depth, [])
  		PPM.write('small.ppm', image)
	end

	#returns a list of tuples : should return a list containing lists containing tuples.
	def madnelbrot(1, 0, _, _, _, _, acc) do acc end 
	def mandelbrot(width, 0, x, y, k, depth, acc) do
		trans = fn(h, w) -> Comp.new(x + k * (w - 1), y - k * (h - 1)) end #--------------------------->function that creates complex numbers
#		IO.puts("width: #{width}, height: 0")
		acc ++ [rows(width, 0, trans, depth, [])]
	end
	def mandelbrot(width, height, x, y, k, depth, acc) do
  		trans = fn(w, h) -> Comp.new(x + k * (w - 1), y - k * (h - 1)) end #-------------------------->function that creates complex numbers
#		IO.puts("width: #{width}, height: #{height}")
		mandelbrot(width, height-1, x, y, k, depth, acc ++ [rows(width, height, trans, depth, [])]) #--->recursion for getting list of rows (height-1)
	end



	def rows(0, _, _, _, acc) do 
		IO.puts(is_list(acc))#------------------------------------------------------------------------->returns a list : true
		acc
	end	
	def rows(width, height, trans, depth, acc) do 
		brot = Brot.mandelbrot(trans.(width, height), depth)
		IO.puts("* width: #{width}, height: #{height}")
		rows(width-1, height, trans, depth, acc ++ [Color.convert(brot, 5)])#---------------------------->recursion for getting the elements of a row
	end

end

defmodule Brot do 
	def mandelbrot(c, m) do  #given the complex number and the threshold	
		test(0, Comp.new(0, 0), c, m)
	end	

	def test(i, _, _, 0) do 
		i
	end
	def test(i, z0, c, m) do
		zn = (Comp.add(Comp.sqr(z0), c)) 	
		mag = Comp.abs(zn)
		cond do 
			mag > 2 -> mag 
			mag < 2 -> test(i, zn, c, m-1)
		end
	end
end


defmodule PPM do

  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.

  def write(name, image) do
    	height = length(image)
    	width = length(List.first(image))
    	{:ok, fd} = File.open(name, [:write])
    	IO.puts(fd, "P6")
    	IO.puts(fd, "#generated by ppm.ex")
    	IO.puts(fd, "#{width} #{height}")
    	IO.puts(fd, "255")
    	rows(image, fd)
    	File.close(fd)
  end

  defp rows(rows, fd) do
	  Enum.each(rows, fn(r) -> 	colors = row(r) 
	  							IO.write(fd, colors)
							end)
  end

  defp row(row) do
#	  IO.puts(row)
	  List.foldr(row, [], fn({r, g, b}, a) -> [r, g, b | a] end)				#({:rgb, r, g, b}, a) -> [r, g, b | a] end)
  end

end

defmodule Color do 
	def convert(depth, max) do 
		f = trunc(div(trunc(depth*10000), max) * 0.0004)
		x = trunc(f)
		y = trunc(255*(f-x))
		case f do 
			0 -> {y, 0, 0} 
			1 -> {0, 255-y, 255}
			2 -> {0, 200, 255}
			3 -> {0, 235, 255}
			_ -> {0, 255, 255}
		end
	end
end
